# 操作系统相关常见问题

## 什么是进程？

```linux
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 
每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
```

## 什么是线程？

```linux
线程是进程的一个实体，线程是内核态，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 
线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
```

## 进程与线程的区别？

```linux
资源：进程间的资源相互独立，同一进程的各线程间共享资源；某进程的线程在其他进程不可见。  

通信：进程间通信：消息传递、同步、共享内存、远程过程调用、管道。线程间通信：直接读写进程数据段（需要进程同步和互斥手段的辅助，以保证数据的一致性）。  

调度和切换：线程上下文切换比进程上下文切换要快得多。  
线程是操作系统最小的执行单元，在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。  
```

## 协程

```linux
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
协程拥有自己的寄存器上下文和栈。 
协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
```

## 线程和协程的区别，内核态和用户态

[用户态与内核态 -- 帮你解惑，直达本质](https://zhuanlan.zhihu.com/p/564044252)

![image](./image/kernel.jpeg)

## 一个进程能创建的线程数量受到哪些制约？

[被问懵了：一个进程最多可以创建多少个线程？](https://www.cnblogs.com/xiaolincoding/p/15013929.html)

```linux
进程的虚拟内存空间上限:因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。

系统参数限制:虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。
```

## 怎么查看一个程序是否正常运行，该程序端口为801

```linux
1、通过netstat -ntlp | grep 8010 查询到程序的进程ID  
2、然后通过 top -p pid 查看当前进程运行情况
```

## 如何查找一个文件？

```linux
find /etc -name nginx.conf  
locate nginx.conf  
```

## 怎么查找一个字符串，在哪些文件里?

```linux
grep -Ri "name"
```

## top命令信息解读?

![image](./image/top.png)

```linux
第一行表示的项目依次为当前时间、系统运行时间、当前系统登录用户数目、1/5/10分钟系统平均负载(一般来说，这个负载值应该不太可能超过 1 才对，除非您的系统很忙碌。 
如果持续高于 5 的话，那么.....仔细的看看到底是那个程序在影响整体系统吧！)。
```

```linux
第二行显示的是所有启动的进程、目前运行、挂起 (Sleeping)的和无用(Zombie)的进程。(比较需要注意的是最后的 zombie 那个数值，如果不是 0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！)(stop模式：与sleep进程应区别，sleep会主动放弃cpu，而stop是被动放弃cpu ，例单步跟踪，stop（暂停）的进程是无法自己回到运行状态的)
```

```linux
第三行显示的是目前CPU的使用情况，包括us用户空间占用CPU百分比、sy 内核空间占用CPU百分比、ni 用户进程空间内改变过优先级的进程占用CPU百分比(中断处理占用)、id 空闲CPU百分比、wa 等待输入输出的CPU时间百分比、hi,si,st 三者的意思目录还不清楚 ：)
```

```linux
第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。
```

```linux
第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。
```

```linux
第六行开始展示当前系统进运行的状态。
```

## fork的底层实现方式

```linux
fork的实现分为以下两步
1. 复制进程资源
2. 执行该进程

复制进程的资源包括以下几步
1. 进程pcb
2. 程序体，即代码段数据段等
3. 用户栈
4. 内核栈
5. 虚拟内存池
6. 页表

执行进程的话就比较简单了，只需要将其加入到就绪队列即可，接下来就等待cpu的调度了。
```

## linux常用操作

```linux
ls
alias|unalias
pwd
cd
rm
mkdir
man
touch
chmod
exit
sudo
shutdown
unzip
top
vmstat
cat
ps
kill
vim 
ping
wget
```

## 查端口用什么命令？

```linux
netstat命令各个参数说明如下：
-t : 指明显示TCP端口
-u : 指明显示UDP端口
-l : 仅显示监听套接字
-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序
-n : 不进行DNS轮询，显示IP
```

### 常用案例  

```linux
netstat -ntlp // 查看当前所有TCP端口
netstat -ntulp | grep 80 // 查看所有80端口使用情况
netstat -an | grep 3306  // 查看所有3306端口使用情况
netstat -lanp // 查看一台服务器上面服务及端口
ps -ef | grep mysqld // 查看一个服务有几个端口
netstat -pnt | grep :3306 | wc // 查看某一个端口的连接数量
```

## linux查看cpu负载、磁盘io、内存用什么命令

### 1、使用top命令

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5880b940a4f1489595ccea9c494f2d94~tplv-k3u1fbpfcp-watermark.image?)

| Tasks | 169 total 进程总数 |
| --- | --- |
| 1 running | 正在运行的进程数 |
| 96 sleeping | 睡眠的进程数 |
| 0 stopped | 停止的进程数 |
| 0 zombie | 僵尸进程数 |

| Cpu(s): | CPU使用信息 |
| --- | --- |
| 0.0 us | 用户空间占用CPU百分比 |
| 0.0 sy | 内核空间占用CPU百分比 |
| 0.0 ni | 用户进程空间内改变过优先级的进程占用CPU百分比 |
| 99.9 id | 空闲CPU百分比 |
| 0.0 wa | 等待输入输出的CPU时间百分比 |
| 0.0 hi |  |
| 0.0 si |  |
| 0.0 wa | 体现出当前的磁盘io请求是否频繁。如果 wa的数量比较大，说明等待输入输出的的io比较多。 |

### 2、vmstat

```linux
vmstat命令报告关于线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。
由vmstat命令生成的报告可以用于平衡系统负载活动。
系统范围内的这些统计信息(所有的处理器中)都计算出以百分比表示的平均值，或者计算其总和。

如果发现等待的进程和处在非中断睡眠状态的进程数非常多，并且发送到块设备的块数和从块设备接收到的块数非常大，那就说明磁盘io比较多。
```

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a417b0bf01a64e258a0245553c3fa5c6~tplv-k3u1fbpfcp-watermark.image?)

| procs |  |
| --- | --- |
| r: | 等待运行的进程数 |
| b: | 处在非中断睡眠状态的进程数 |
| w: | 被交换出去的可运行的进程数 |

| Memory |  |
| --- | --- |
| swpd: | 虚拟内存使用情况，单位：KB  |
| free: | 空闲的内存，单位KB  |
| buff: | 被用来做为缓存的内存数，单位：KB  |

| Swap |  |
| --- | --- |
| si: | 从磁盘交换到内存的交换页数量，单位：KB/秒 |
| so: | 从内存交换到磁盘的交换页数量，单位：KB/秒 |

| IO |  |
| --- | --- |
| bi: | 发送到块设备的块数，单位：块/秒  |
| bo: | 从块设备接收到的块数，单位：块/秒  |

| system |  |
| --- | --- |
| in: | 每秒的中断数，包括时钟中断  |
| cs: | 每秒的环境(上下文)切换次数  |

| CPU | 按 CPU 的总使用百分比来显示 |
| --- | --- |
| us: | CPU 使用时间  |
| sy: | CPU 系统使用时间  |
| id: | 闲置时间  |

### 3、iostat

## sleep底层实现原理

```linux
内核的sleep()函数是在挂起原语的基础上利用定时器实现的。

sleep()：进程、线程或任务(Linux中不区分进程与线程，都称为task)可以sleep，这会导致它们暂停执行一段时间，直到等待的时间结束才恢复执行或在这段时间内被中断。

sleep()在OS中的实现的大概流程：

1、挂起进程（或线程）并修改其运行状态
2、用sleep()提供的参数来设置一个定时器。
3、当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。
```

## linux文件系统

[深入理解 ext4 等 Linux 文件系统](https://zhuanlan.zhihu.com/p/44267768)

## 进程挂起，阻塞和睡眠的区别

```linux
从触发机制上：
挂起是主动触发
阻塞是被动的
睡眠是主动触发的


从资源占用角度来说：
阻塞进程不再占用CPU资源，但还在占用调度器和内存资源
挂起进程不再占用CPU和内存资源了
睡眠进程既占用内存资源又占用CPU资源
```

## 进程阻塞怎么处理？就是进程完全不运行了，但是pid还在

[什么是进程阻塞](https://www.cnblogs.com/baxianhua/p/9284973.html)

## 系统上有个大文件，但是不知道文件的名字和路径，在当前用户的用户空间下，如何找到他？

```linux
例子：查找当前目录下文件大小为2048(2k)字节的文件

find ./ -size 4
或
find ./ -size 2048c
或
find ./ -size 2K
上述查找文件是等于指定大小的，那能不能查询大于或小于某个指定值的文件呢，答案是肯定，例如：

查找大于2K的文件，+ 表示大于
find ./ -size +2048c

查找小于2K的文件，- 表示小于
find ./ -size -2048c
```

## 为什么内存操作很快

## linux内核

## 何为惊群效应

- [什么是惊群，如何有效避免惊群?](https://www.zhihu.com/question/22756773)
- [Linux 惊群效应之 Nginx 解决方案](https://zhuanlan.zhihu.com/p/51251700)

```linux
惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么它就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。
```

### 惊群效应消耗了什么

```linux
Linux 内核对用户进程（线程）频繁地做无效的调度、上下文切换等使系统性能大打折扣。上下文切换（context switch）过高会导致 CPU 像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括 CPU 寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核 cache 之间的共享数据。  

为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如 Lighttpd。
```

### Linux解决方案之Accept

```linux
Linux2.6版本之前，监听同一个socket的进程会挂在同一个等待队列上，当请求到来时，会唤醒所有等待的进程。

Linux2.6版本之后，通过引入一个标记位WQ_FLAG_EXCLUSIVE，解决掉了accept惊群效应。
```

### 结论

```linux
不管多进程还是多线程，都存在惊群效应，本篇文章使用多进程分析。  
在 Linux2.6 版本之后，已经解决了系统调用accept的惊群效应（前提是没有使用select、poll、epoll 等事件机制）。
目前Linux已经部分解决了epoll的惊群效应（epoll 在 fork 之前），Linux2.6是没有解决的。
Epoll 在 fork 之后创建仍然存在惊群效应，Nginx 使用自己实现的互斥锁解决惊群效应。
```

## 物理CPU

```linux
物理CPU就是计算机上实际配置的CPU个数。在linux上可以打开cat /proc/cpuinfo 来查看，其中的physical id就是每个物理CPU的ID，你能找到几个physical id就代表你的计算机实际有几个CPU。在linux下可以通过指令 grep ‘physical id’ /proc/cpuinfo | sort -u | wc -l 来查看你的物理CPU个数
```

## cpu核数  

```linux
核数就是指CPU上集中的处理数据的cpu核心个数，单核指cpu核心数一个，双核则指的是两个。通常每个CPU下的核数都是固定的，比如你的计算机有两个物理CPU，每个CPU是双核，那么计算机就是四核的。linux的cpu核心总数也可以在/proc/cpuinfo里面通过指令cat /proc/cpuinfo查看的到，其中的core id指的是每个物理CPU下的cpu核的id，能找到几个core id就代表你的计算机有几个核心。也可以使用指令cat /proc/cpuinfo | grep “cpu cores” | wc -l来统计cpu的核心总数。
```

## 逻辑CPU  

```linux
操作系统可以使用逻辑CPU来模拟出真实CPU的效果。在之前没有多核处理器的时候，一个CPU只有一个核，而现在有了多核技术，其效果就好像把多个CPU集中在一个CPU上。当计算机没有开启超线程时，逻辑CPU的个数就是计算机的核数。而当超线程开启后，逻辑CPU的个数是核数的两倍。实际上逻辑CPU的数量就是平时称呼的几核几线程中的线程数量，在linux的cpuinfo中逻辑CPU数就是processor的数量。可以使用指令cat /proc/cpuinfo | grep “processor” | wc -l来查看逻辑CPU数。 知道上面这些，常说的几核几线程就好理解了。假设计算机有一个物理CPU，是双核的，支持超线程。那么这台计算机就是双核四线程的。  所以两路（两路指的是有两个物理CPU）四核超线程就有2*4*2=16个逻辑CPU。有人也把它称之为16核，实际上在linux的/proc/cpuinfo中查看只有8核。 既然计算机多核与超线程模拟相关，所以实际上计算机的核数翻倍并不意味着性能的翻倍，也不意味着核数越多计算机性能会越来越好，因为超线程只是充分利用了CPU的空闲资源，实际上在应用中基于很多原因，CPU的执行单元都没有被充分使用。
```
