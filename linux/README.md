# 操作系统相关常见问题

## 什么是进程？

进程是计算机中正在执行的程序实例，它具有程序代码、数据、内存空间、寄存器等执行所需的资源。每个进程都有自己的执行状态，包括运行、就绪、等待等，它们是由操作系统进行管理和调度的。

在操作系统中，每个进程都有一个唯一的标识符PID（进程标识符），用于区分不同的进程。进程可以通过创建子进程来实现并发执行，并且它们可以与其他进程共享资源，如文件、网络连接等。

进程是操作系统中最基本的执行单位，它们可以执行各种任务，如打印文档、运行应用程序、处理网络请求等。操作系统通过分配和管理进程资源，实现了计算机的多任务处理和并发执行。

## 什么是线程？

线程是计算机程序执行的最小单位，也是操作系统能够进行运算调度的最小单位。一个进程中可以包含多个线程，这些线程可以并发地执行不同的任务，共享进程的内存空间和系统资源。线程通常可以提高程序的执行效率，特别是在处理多任务或多用户并发请求的情况下。线程可以通过操作系统或编程语言提供的API来创建、启动和管理。

## 进程与线程的区别？

进程和线程都是计算机程序执行的基本单位，但它们有以下区别：

1、资源占用：进程拥有独立的内存空间和系统资源，如文件、网络端口等，而线程共享进程的内存空间和系统资源。

2、调度：进程作为操作系统的基本调度单位，进程的创建、调度、切换都需要操作系统进行管理。而线程是在进程内部创建和管理的，线程的切换和调度相对于进程来说更加轻量级，所以线程的切换开销更小。

3、并发性：不同进程之间相互独立，一个进程的崩溃不会影响其他进程的运行。而线程之间是共享进程资源的，一个线程的错误可能会影响进程内的其他线程。

4、通信：不同进程之间通信需要使用特殊的机制，如管道、消息队列、共享内存等。而线程之间可以通过共享内存等方式进行通信。

5、创建和销毁：创建和销毁一个进程的开销较大，需要操作系统进行较多的资源分配和回收操作。而线程的创建和销毁相对来说比较轻量级，可以在进程内部快速完成。

综上所述，进程和线程各有优劣，需要根据具体应用场景进行选择和使用。

## 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
协程拥有自己的寄存器上下文和栈。 
协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## 线程和协程的区别，内核态和用户态

[用户态与内核态 -- 帮你解惑，直达本质](https://zhuanlan.zhihu.com/p/564044252)

![image](./image/kernel.jpeg)

## 一个进程能创建的线程数量受到哪些制约？

[被问懵了：一个进程最多可以创建多少个线程？](https://www.cnblogs.com/xiaolincoding/p/15013929.html)

进程的虚拟内存空间上限:因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。

系统参数限制:虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。

## 怎么查看一个程序是否正常运行，该程序端口为801

1、通过netstat -ntlp | grep 8010 查询到程序的进程ID  
2、然后通过 top -p pid 查看当前进程运行情况

## 如何查找一个文件？

```linux
find /etc -name nginx.conf  
locate nginx.conf  
```

## 怎么查找一个字符串，在哪些文件里?

```linux
grep -Ri "name"
```

## top命令信息解读?

![image](./image/top.png)

第一行表示的项目依次为当前时间、系统运行时间、当前系统登录用户数目、1/5/10分钟系统平均负载(一般来说，这个负载值应该不太可能超过 1 才对，除非您的系统很忙碌。 
如果持续高于 5 的话，那么.....仔细的看看到底是那个程序在影响整体系统吧！)。

第二行显示的是所有启动的进程、目前运行、挂起 (Sleeping)的和无用(Zombie)的进程。(比较需要注意的是最后的 zombie 那个数值，如果不是 0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！)(stop模式：与sleep进程应区别，sleep会主动放弃cpu，而stop是被动放弃cpu ，例单步跟踪，stop（暂停）的进程是无法自己回到运行状态的)

第三行显示的是目前CPU的使用情况，包括us用户空间占用CPU百分比、sy 内核空间占用CPU百分比、ni 用户进程空间内改变过优先级的进程占用CPU百分比(中断处理占用)、id 空闲CPU百分比、wa 等待输入输出的CPU时间百分比、hi,si,st 三者的意思目录还不清楚 ：)

第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。

第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。

第六行开始展示当前系统进程运行的状态。

## fork的底层实现方式

在计算机科学中，"fork"指的是一种创建新进程的系统调用。当一个进程调用fork时，操作系统会创建一个新的进程，这个新进程和原始进程几乎完全相同，但它是一个独立的进程，拥有自己的地址空间、堆栈和文件描述符等。新进程的代码、数据和堆栈都是原始进程的副本。

在Unix/Linux系统中，fork的底层实现方式通常是通过复制当前进程的内存映像来创建新的进程。具体而言，当一个进程调用fork时，操作系统会创建一个新的进程控制块（Process Control Block, PCB），并将当前进程的PCB复制到新进程的PCB中。然后，操作系统会为新进程创建一个新的用户地址空间，并将当前进程的地址空间复制到新进程的地址空间中。在这个过程中，操作系统会复制当前进程的代码、数据和堆栈等，但不会复制打开文件和网络连接等资源。新进程的PCB和地址空间都是独立于当前进程的，因此它们可以独立运行和执行不同的操作。

需要注意的是，fork并不是一个原子操作，它需要操作系统在内核空间中执行多个步骤来完成。在fork调用期间，操作系统会暂停当前进程的执行，复制当前进程的内存映像，然后启动新进程，将它加入调度队列中等待执行。因此，在fork调用返回之前，当前进程和新进程都可能运行并执行不同的操作。

```linux
fork的实现分为以下两步
1. 复制进程资源
2. 执行该进程

复制进程的资源包括以下几步
1. 进程pcb
2. 程序体，即代码段数据段等
3. 用户栈
4. 内核栈
5. 虚拟内存池
6. 页表

执行进程的话就比较简单了，只需要将其加入到就绪队列即可，接下来就等待cpu的调度了。
```

## linux常用操作

```linux
ls
alias|unalias
pwd
cd
rm
mkdir
man
touch
chmod
exit
sudo
shutdown
unzip
top
vmstat
cat
ps
kill
vim 
ping
wget
```

## 查端口用什么命令？

```linux
netstat命令各个参数说明如下：
-t : 指明显示TCP端口
-u : 指明显示UDP端口
-l : 仅显示监听套接字
-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序
-n : 不进行DNS轮询，显示IP
```

### 常用案例  

```linux
netstat -ntlp // 查看当前所有TCP端口
netstat -ntulp | grep 80 // 查看所有80端口使用情况
netstat -an | grep 3306  // 查看所有3306端口使用情况
netstat -lanp // 查看一台服务器上面服务及端口
ps -ef | grep mysqld // 查看一个服务有几个端口
netstat -pnt | grep :3306 | wc // 查看某一个端口的连接数量
```

## linux查看cpu负载、磁盘io、内存用什么命令

查看系统负载：top命令  
使用 top 命令可以实时查看系统的 CPU 占用情况、内存占用情况、进程信息等。在 top 命令中，系统负载由三个值组成，分别表示系统负载的 1 分钟、5 分钟和 15 分钟的平均值。

查看磁盘IO：iostat命令  
使用 iostat 命令可以查看磁盘的读写情况、I/O 请求的处理时间、队列长度等信息。

查看内存使用情况：free命令  
使用 free 命令可以查看系统内存的总量、已用内存、空闲内存、缓存和缓冲区使用情况等信息。可以通过 free -h 命令将内存使用情况显示为人类可读的格式。

### 1、使用top命令

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5880b940a4f1489595ccea9c494f2d94~tplv-k3u1fbpfcp-watermark.image?)

| Tasks | 169 total 进程总数 |
| --- | --- |
| 1 running | 正在运行的进程数 |
| 96 sleeping | 睡眠的进程数 |
| 0 stopped | 停止的进程数 |
| 0 zombie | 僵尸进程数 |

| Cpu(s): | CPU使用信息 |
| --- | --- |
| 0.0 us | 用户空间占用CPU百分比 |
| 0.0 sy | 内核空间占用CPU百分比 |
| 0.0 ni | 用户进程空间内改变过优先级的进程占用CPU百分比 |
| 99.9 id | 空闲CPU百分比 |
| 0.0 wa | 等待输入输出的CPU时间百分比 |
| 0.0 hi |  |
| 0.0 si |  |
| 0.0 wa | 体现出当前的磁盘io请求是否频繁。如果 wa的数量比较大，说明等待输入输出的的io比较多。 |

### 2、vmstat

vmstat命令报告关于线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。
由vmstat命令生成的报告可以用于平衡系统负载活动。
系统范围内的这些统计信息(所有的处理器中)都计算出以百分比表示的平均值，或者计算其总和。

如果发现等待的进程和处在非中断睡眠状态的进程数非常多，并且发送到块设备的块数和从块设备接收到的块数非常大，那就说明磁盘io比较多。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a417b0bf01a64e258a0245553c3fa5c6~tplv-k3u1fbpfcp-watermark.image?)

| procs |  |
| --- | --- |
| r: | 等待运行的进程数 |
| b: | 处在非中断睡眠状态的进程数 |
| w: | 被交换出去的可运行的进程数 |

| Memory |  |
| --- | --- |
| swpd: | 虚拟内存使用情况，单位：KB  |
| free: | 空闲的内存，单位KB  |
| buff: | 被用来做为缓存的内存数，单位：KB  |

| Swap |  |
| --- | --- |
| si: | 从磁盘交换到内存的交换页数量，单位：KB/秒 |
| so: | 从内存交换到磁盘的交换页数量，单位：KB/秒 |

| IO |  |
| --- | --- |
| bi: | 发送到块设备的块数，单位：块/秒  |
| bo: | 从块设备接收到的块数，单位：块/秒  |

| system |  |
| --- | --- |
| in: | 每秒的中断数，包括时钟中断  |
| cs: | 每秒的环境(上下文)切换次数  |

| CPU | 按 CPU 的总使用百分比来显示 |
| --- | --- |
| us: | CPU 使用时间  |
| sy: | CPU 系统使用时间  |
| id: | 闲置时间  |

### 3、iostat

## sleep底层实现原理

内核的sleep()函数是在挂起原语的基础上利用定时器实现的。

sleep()：进程、线程或任务(Linux中不区分进程与线程，都称为task)可以sleep，这会导致它们暂停执行一段时间，直到等待的时间结束才恢复执行或在这段时间内被中断。

sleep()在OS中的实现的大概流程：

1、挂起进程（或线程）并修改其运行状态
2、用sleep()提供的参数来设置一个定时器。
3、当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。

## linux文件系统

[深入理解 ext4 等 Linux 文件系统](https://zhuanlan.zhihu.com/p/44267768)

## 进程挂起，阻塞和睡眠的区别

||触发机制|资源|
|----|----|----|
|挂起|主动触发|挂起进程不再占用CPU和内存资源了|
|阻塞|被动的|阻塞进程不再占用CPU资源，但还在占用调度器和内存资源|
|睡眠|主动触发|睡眠进程既占用内存资源又占用CPU资源|


进程挂起（Suspend）：  
进程挂起是指将一个正在执行的进程暂停运行，并将其状态保存到硬盘中。这样，当需要时可以将进程恢复并继续执行，恢复后的进程将继续执行被挂起时的代码。进程挂起通常是为了释放资源或者协调进程间的调度。

进程阻塞（Block）：  
进程阻塞是指一个进程因等待某种资源或者等待某个事件的发生而被暂停运行。当需要等待的资源或事件未到达时，进程会进入阻塞状态，此时操作系统会将进程移出就绪队列，以便让其他进程使用CPU资源。一旦等待的资源或事件到达，进程会被唤醒并继续执行。

进程睡眠（Sleep）：  
进程睡眠是指进程主动让出CPU并进入睡眠状态，等待一定的时间后再次被唤醒。在睡眠期间，进程不会占用CPU资源，这有助于减少系统的负载。进程睡眠通常是为了进行定时任务或者等待某些事件的发生。

综上所述，进程挂起、阻塞和睡眠是三个不同的操作系统概念，它们都涉及到进程状态的转换和资源的管理，但具体的实现方式和应用场景有所不同。

## 进程阻塞怎么处理？就是进程完全不运行了，但是pid还在

[什么是进程阻塞](https://www.cnblogs.com/baxianhua/p/9284973.html)

进程阻塞是指进程无法继续执行下去，因为它正在等待某个事件的发生，例如等待文件读取完成、等待网络数据到达等。处理进程阻塞的方法通常有以下几种：

超时等待：设置一个定时器，如果在一定时间内事件没有发生，就放弃等待并进行其他操作。这种方法适用于等待时间较长的情况，避免进程无限制地等待下去。

异步回调：使用异步编程模型，将等待事件的回调函数传递给操作系统或其他模块，当事件发生时自动调用回调函数，从而避免进程阻塞。

多线程：创建多个线程，让一个线程等待事件的发生，当事件发生时通知其他线程继续执行。这种方法适用于等待时间较短的情况，避免进程过多地切换，浪费系统资源。

信号量和管道：使用信号量和管道等进程间通信的机制，实现进程之间的同步和通信，从而避免进程阻塞。

总之，处理进程阻塞需要根据具体情况采取不同的方法，避免进程无限制地等待下去，从而提高系统的响应能力和资源利用率。

## 系统上有个大文件，但是不知道文件的名字和路径，在当前用户的用户空间下，如何找到他？

```linux
例子：查找当前目录下文件大小为2048(2k)字节的文件

find ./ -size 4
或
find ./ -size 2048c
或
find ./ -size 2K
上述查找文件是等于指定大小的，那能不能查询大于或小于某个指定值的文件呢，答案是肯定，例如：

查找大于2K的文件，+ 表示大于
find ./ -size +2048c

查找小于2K的文件，- 表示小于
find ./ -size -2048c
```

## 为什么内存操作很快

内存通常是由DRAM（动态随机存储器）构成，DRAM中的存储单元被组织成一个网格状的数组。每个存储单元都有一个唯一的地址，CPU可以通过这个地址访问存储单元中的数据。内存操作的速度非常快，因为DRAM是由电容和晶体管组成的，读写数据只需要通过电信号就可以实现，这个过程比硬盘读写的机械运动和磁头寻址要快得多。

此外，内存操作还受到CPU的缓存机制的影响。CPU通常有多级缓存，其中L1缓存是最快的缓存，它的速度比内存快几倍甚至更多。当CPU需要访问内存中的数据时，它会先在L1缓存中查找，如果L1缓存中没有找到，就会继续查找L2、L3等缓存，最终才会访问内存。通过缓存机制，CPU能够将频繁访问的数据存储在缓存中，从而避免频繁地访问内存，提高了程序的执行效率。

## linux内核

## 何为惊群效应

- [什么是惊群，如何有效避免惊群?](https://www.zhihu.com/question/22756773)
- [Linux 惊群效应之 Nginx 解决方案](https://zhuanlan.zhihu.com/p/51251700)

惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么它就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。

### 惊群效应消耗了什么

Linux 内核对用户进程（线程）频繁地做无效的调度、上下文切换等使系统性能大打折扣。上下文切换（context switch）过高会导致 CPU 像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括 CPU 寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核 cache 之间的共享数据。  

为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如 Lighttpd。

### Linux解决方案之Accept

```linux
Linux2.6版本之前，监听同一个socket的进程会挂在同一个等待队列上，当请求到来时，会唤醒所有等待的进程。

Linux2.6版本之后，通过引入一个标记位WQ_FLAG_EXCLUSIVE，解决掉了accept惊群效应。
```

### 结论

不管多进程还是多线程，都存在惊群效应，本篇文章使用多进程分析。  
在 Linux2.6 版本之后，已经解决了系统调用accept的惊群效应（前提是没有使用select、poll、epoll 等事件机制）。
目前Linux已经部分解决了epoll的惊群效应（epoll 在 fork 之前），Linux2.6是没有解决的。
Epoll 在 fork 之后创建仍然存在惊群效应，Nginx 使用自己实现的互斥锁解决惊群效应。

## 物理CPU

物理CPU就是计算机上实际配置的CPU个数。
在linux上可以打开cat /proc/cpuinfo 来查看，其中的physical id就是每个物理CPU的ID，
你能找到几个physical id就代表你的计算机实际有几个CPU。

在linux下可以通过指令 grep 'physical id' /proc/cpuinfo | sort -u | wc -l 来查看你的物理CPU个数

## cpu核数

核数就是指CPU上集中的处理数据的cpu核心个数，单核指cpu核心数一个，双核则指的是两个。
通常每个CPU下的核数都是固定的，比如你的计算机有两个物理CPU，每个CPU是双核，那么计算机就是四核的。
linux的cpu核心总数也可以在/proc/cpuinfo里面通过指令cat /proc/cpuinfo查看的到，
其中的core id指的是每个物理CPU下的cpu核的id，能找到几个core id就代表你的计算机有几个核心。

可以使用指令 grep 'cpu cores' /proc/cpuinfo | wc -l 来统计cpu的核心总数。

## 逻辑CPU

操作系统可以使用逻辑CPU来模拟出真实CPU的效果。在之前没有多核处理器的时候，一个CPU只有一个核，
而现在有了多核技术，其效果就好像把多个CPU集中在一个CPU上。

当计算机没有开启超线程时，逻辑CPU的个数就是计算机的核数。而当超线程开启后，逻辑CPU的个数是核数的两倍。

实际上逻辑CPU的数量就是平时称呼的几核几线程中的线程数量，在linux的cpuinfo中逻辑CPU数就是processor的数量。
可以使用指令 grep 'processor' /proc/cpuinfo | wc -l 来查看逻辑CPU数。

知道上面这些，常说的几核几线程就好理解了。
假设计算机有一个物理CPU，是双核的，支持超线程。那么这台计算机就是双核四线程的。  
所以两路（两路指的是有两个物理CPU）四核超线程就有2*4*2=16个逻辑CPU。
有人也把它称之为16核，实际上在linux的/proc/cpuinfo中查看只有8核。

既然计算机多核与超线程模拟相关，所以实际上计算机的核数翻倍并不意味着性能的翻倍，
也不意味着核数越多计算机性能会越来越好，因为超线程只是充分利用了CPU的空闲资源，
实际上在应用中基于很多原因，CPU的执行单元都没有被充分使用。
