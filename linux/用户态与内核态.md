# 内核

## CPU 指令集权限

### 1. 什么是CPU 指令集

```linux
指令集是 CPU 实现软件指挥硬件执行工作的媒介，具体来说每一条汇编语句都对应了一条 CPU 指令，CPU 指令不止一条的，而是由非常非常多的 CPU 指令集合在一起，组成了一个、甚至多个的集合，每个指令的集合叫：CPU 指令集。随着时间的推移，CPU 指令越来越多，从最早的几十条，到现在的几千条

Inter、AMD CPU 都是复杂指令集 CPU，支持的 CPU 指令多达几千个，每一个指令都指代一种数学运算，比如加减乘除4种数学计算在 CPU 中就是 4条 CPU 指令，以此类推，大家脑补下

CPU 指令集发展到现在有很多的，典型的 Intel CPU 支持：EM64T, MMX, SSE, SSE2 ，SSE3，SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX-512, VMX 等指令集

这些指令集中，每个 CPU 指令都有唯一的、不重复的指令编号，CPU 硬件中的 控制单元 可以解析、识别程序想要执行的 CPU 指令的编号，然后指挥相关硬件执行相关操作，所以 汇编语言 被视为是最底层的编程语言

一般认为：CPU 硬件直接支持的数学计算公式执行效率最高。就是因为 CPU 指令集中包含这个数学公式，数学计算只需要一条指令就可以执行完毕。反之就需要通过多条 CPU 指令以组合的方式完成数学计算，需要执行多条 CPU 指令，在空间和时间复杂度上都会复杂 N 倍。所以请大家理解 CPU 执行效率高低的来源，当然指令集只是制约 CPU 执行效率高低的其中一个因素，但是该因素绝对是重量级的、起决定性的因素
```

## 2. CPU 指令权限分级

```linux
CPU 指令也是有权限分级的 --> 大家试想，CPU 指令是可以直接操作硬件的，要是因为指令操作的不规范，造成的错误是会影响整个 计算机系统 的。好比你写 一个程序，但是因为你对 硬件操作 不熟悉，出现问题，那么影响范围是多大？是整个计算机系统，操作系统内核、及其其他所有正在运行的程序，都会因为你操作失误而受到不可挽回的错误，那么你只有重启整个计算机才行

而对于 硬件的操作 是非常复杂的，参数众多，出问题的几率相当大，必须及其谨慎的进行操作，这对于个人开发者来说是个艰巨的任务，同时个人开发者在这方面也是不被信任的。所以 操作系统内核 直接屏蔽了个人开发者对于硬件操作的可能，我都不让你能碰到这些 CPU 指令，你还能搞个大新闻出来嘛~

这方面 系统内核 对 硬件操作 进行了封装处理，对外提供标准函数库，操作更简单、更安全。比如 我们要打开一个文件，C标准函数库中对应的是fopen()，其内部封装的是内核中的系统函数open()

因为这个需求，硬件设备商直接提供了硬件级别的支持，做法就是对 CPU 指令设置了 权限，不同级别的权限可以使用的 CPU 指令是有限制的。以 Inter CPU 为例，Inter 把 CPU 指令操作的权限划为4级：

ring 0
ring 1
ring 2
ring 3

其中 ring 0 权限最高，可以使用所有 CPU 指令，ring 3 权限最低，仅能使用常规 CPU 指令，这个级别的权限不能使用访问硬件资源的指令，比如 IO 读写、网卡访问、申请内存都不行，都没有权限

Linux 系统内核采用了：ring 0 和 ring 3 这2个权限

ring0被叫做 内核态，完全在 操作系统内核 中运行，由专门的 内核线程 在 CPU 中执行其任务
ring3被叫做 用户态，在 应用程序 中运行，由 用户线程 在 CPU 中执行其任务

```

## 用户态、内核态

### 1. 用户态、内核态是什么

```linux
用户态、内核态是什么呢？其实不是多复杂。用户态、内核态的概念就是指 CPU 指令权限的区别，你要在应用程序中读写 IO，那么就必然会用到 ring 0 级别的 CPU 指令，而应用程序的 CPU 指令权限只有 ring 3，那么就必须到拥有 ring0 权限的系统内核 中去执行这行代码，必然会造成 CPU 从 用户态到内核态 的切换。

其表现形式是：代码会从应用程序所在的 用户线程 切换到 内核中的 内核线程 去执行，就是这么回事
```

### 2. 用户态、内核态在资源上的区别

```linux
CPU 指令权限的高低，一样会反映在对资源的操作上，区别就是高 CPU 指令权限可以操作更多、更核心的资源，典型的就是内存和硬件资源
```

虽然从概念上说：用户态、内核态 只是 CPU 指令权限的区别，但是在 程序、系统内核设计上，必然会有相对应的运行机制来支持的，这体现在2个显著的区别上：

```linux
用户态的代码必须由 用户线程 去执行、内核态的代码必须由 内核线程 去执行
用户态、内核态 或者说 用户线程、内核线程 可以使用的资源是不同的，尤体现在内存资源上。Linux 内核对每一个进程都会分配 4G 虚拟内存空间地址
用户态： --> 只能操作 0-3G 的内存地址
内核态： --> 0-4G 的内存地址都可以操作，尤其是对 3-4G 的高位地址必须由内核态去操作，因为所有进程的 3-4G 的高位地址使用的都是同一块、专门留给 系统内核 使用的 1G 物理内存
3.所有对 硬件资源、系统内核数据 的访问都必须由内核态去执行
```
