# Golang常见问题

## 编译原理

[Golang编译原理](./compile.md)

### go的init函数是什么时候执行的？

### 多个init函数执行顺序能保证吗？

## 数据结构

[Golang数据结构](./struct.md)

### 切片的底层实现说一下？

### Go中对nil的Slice和空的Slice的处理是一致的吗？

nil slice和empty slice是不一致的

### slice，len，cap，共享，扩容

### slice和array区别

### 创建一个数组底层扩容

### 如何把数组转化成一个切片

### 数组和切片的区别

### map和sync.map是有什么区别？看过源码吗，可以介绍一下吗？

### map里面解决hash冲突怎么做的，冲突了元素放在头还是尾

### map取一个key，然后修改这个值，原map数据的值会不会变化

### map如何顺序读取

### struct能不能比较

### go里面interface是什么概念

### go什么场景使用接口

### 函数传递有什么区别

### 相比于javac++interface有什么区别吗？

### make一个slice参数怎么写？

### map会遇到一些并发安全的问题，为什么就并发不安全了？

### 为什么给变量一个基础类型没有并发安全问题？

### 数组和切片的关系和区别

### 结构体传递场景

### string和byte数组有什么区别？

### go结构体和结构体指针的区别

### go深拷贝，什么时候需要深拷贝

### 并发读写map会发生什么？怎么避免?

fatal error: concurrent map read and map write  
会发生并发读写问题

1、在1.9之前可以定义一个结构体加上一把读写锁来解决并发安全问题；
2、1.9之后官方在sync包定义了Map结构体，如果遇到并发问题，可以使用sync.Map解决。  

## 语法基础

## 常用关键字

### defer是啥？怎么用的，底层原理是啥？

### defer用的多吗？有哪些应用

### 异常捕获是如何做的？

### select可以用于什么

### go如何避免panic

### append时的过程

针对切片类型持续进行append可能会导致切片进行扩容

校验是否赋值原有变量

**如果不赋值原有变量:**

1、首先获取当前切片的数组指针、大小、容量  
2、如果追加的元素后，长度大于容量，会触发切片的扩容  
3、最后将追加的元素添加到指定的数组中

**如果赋值原有变量:**  

Go语言编译器已经对这种常见的情况做出了优化  
其他步骤与不赋值原有变量逻辑一致  

**append引发的扩容:**

1、如果期望容量大于当前容量的两倍就会使用期望容量；  
2、如果当前切片的长度小于 1024 就会将容量翻倍；  
3、如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；  

以上仅是针对容量大小的简单计算，还会设计内存对齐

需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能。

## 并发编程

[Golang并发模型](./concurrent.md)

### context

上下文是Go语言中用来设置截止日期、同步信号，传递请求相关值的接口类型；上下文与Goroutine有比较密切的关系；

```golang
type Context interface {
 Deadline() (deadline time.Time, ok bool)
 Done() <-chan struct{}
 Err() error
 Value(key interface{}) interface{}
}
```

主要作用是在多个Goroutine组成的树中同步取消信号以减少对资源的消耗和占用；还有传值的功能，但是这个功能我们还是很少用到。

### go并发机制

### Go语言的互斥锁是怎么实现的？读写锁呢？

### sync pool的实现原理

### go waitgroup的坑

### 读写锁说下

### go的锁是可重入的吗？

### 获取不到锁会一直等待吗？

### 如何实现一个线程安全的map

### 那如何实现一个timeout的锁？

### golang支持哪些并发机制

### go用共享内存的方式实现并发如何保证安全？

### golang wait.group用过吗？

### go里面map是并发安全的吗？不是并发安全该如何使用？

### 怎么理解“不要用共享内存来通信，而是用通信来共享内存”

## 调度器

- [Golang调度器](./scheduler.md)
- [[Golang三关-典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
- [6.5 调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)

### Go语言调度器的发展史说一下？

**单线程调度器 · 0.x：**  
只包含 40 多行代码；  
程序中只能存在一个活跃线程，由 G-M 模型组成；

**多线程调度器 · 1.0：**  
允许运行多线程的程序；  
全局锁导致竞争严重；

**任务窃取调度器 · 1.1：**  
引入了处理器 P，构成了目前的 G-M-P 模型；  
在处理器 P 的基础上实现了基于工作窃取的调度器；  
在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；  
时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；

**抢占式调度器 · 1.2 ~ 至今：**  
基于协作的抢占式调度器 - 1.2 ~ 1.13  
通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；  
Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；  
基于信号的抢占式调度器 - 1.14 ~ 至今  
实现基于信号的真抢占式调度；  
垃圾回收在扫描栈时会触发抢占调度；  
抢占的时间点不够多，还不能覆盖全部的边缘情况；  

**非均匀存储访问调度器 · 提案**  
对运行时的各种资源进行分区；  
实现非常复杂，到今天还没有提上日程；  

### GMP模型是什么？为什么要有P？

Go1.0 的 GM 模型的 Goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，尤其是高吞吐量服务器和并行计算程序。

#### GM实现有如下的问题

**存在单一的全局 mutex（Sched.Lock）和集中状态管理：**  
mutex 需要保护所有与 goroutine 相关的操作（创建、完成、重排等），导致锁竞争严重。

**Goroutine 传递的问题：**  
goroutine（G）交接（G.nextg）：工作者线程（M's）之间会经常交接可运行的 goroutine。  
上述可能会导致延迟增加和额外的开销。每个 M 必须能够执行任何可运行的 G，特别是刚刚创建 G 的 M。

**每个 M 都需要做内存缓存（M.mcache）：**  
会导致资源消耗过大（每个 mcache 可以吸纳到 2M 的内存缓存和其他缓存），数据局部性差。  

**频繁的线程阻塞/解阻塞：**  
在存在 syscalls 的情况下，线程经常被阻塞和解阻塞。这增加了很多额外的性能开销。

#### 加入P带来什么改变

- 每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。  
- 每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。

#### 为什么要有 P

- 一般来讲，M 的数量都会多于 P。像在 Go 中，M 的数量默认是 10000，P 的默认数量的 CPU 核数。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了 M，又不够用的情况下，M 会不断增加。
- M 不断增加的话，如果本地队列挂载在 M 上，那就意味着本地队列也会随之增加。这显然是不合理的，因为本地队列的管理会变得复杂，且 Work Stealing 性能会大幅度下降。  
- M 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。

### 主协程如何等其余协程完再操作

主协程自我阻塞，直到需要的协程完成  
阻塞方法  

**使用sync.WaitGroup()管理其余协程：**  
优点：操作简单  
缺点：不能管控协程的执行完成的顺序  

**利用缓存管道进行协程之间的通信：**  
优点：能够管控一组协程结束  
缺点：不能管控协程的执行完成顺序  

**利用无缓存管道进行协程之间的通信：**  
优点：能够管控协程执行完成的顺序  

### Goroutine是什么？能介绍一下它吗？

Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。

Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。

### goroutine创建数量有限制吗？

理论上没有限制，但是因为协程同样消耗CPU、内存等资源，所以是最好限制一下协程数量

**通过channel限制goroutine：**

```golang
type Limit struct {
 n   int
 c   chan struct{}
 ctx context.Context
}

func NewLimit(ctx context.Context, n int) *Limit {
 return &Limit{
  n:   n,
  c:   make(chan struct{}, n),
  ctx: ctx,
 }
}

// Run f in a new goroutine but with limit.
func (g *Limit) Run(f func(ctx context.Context)) {
 g.c <- struct{}{}
 go func() {
  f(g.ctx)
  <-g.c
 }()
}

```

### 为什么不要频繁创建和停止goroutine

### go里面为什么需要多协程？

### goroutine为什么会存在，为什么不使用线程？

### 同时启了一万个g，如何调度的？

### 一个进程能创建多少线程受哪些因素的限制

### goroutine在项目里面主要承担了什么责任

提供并发性能

### 用go协程的时候也是要走IO的，go是如何处理的？

### 为什么不要大量使用goroutine

在Go语言中，goroutine的创建成本很低，调度效率高，Go语言在设计时就是按以数万个goroutine为规范进行设计的，数十万个并不意外，但是goroutine在内存占用方面确实具有有限的成本，你不能创造无限数量的它们

### 并行goroutine如何实现

可以通过管道或者sync.WaitGroup

### go协程、线程、进程区别

​协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。

线程和进程属于内核态

协程属于用户态

**协程（coroutine）：**  
和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。它避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。

Goroutine和其他语言的协程（coroutine）在使用方式上类似，但从字面意义上来看不同（一个是Goroutine，一个是coroutine），再就是协程是一种协作任务控制机制，在最简单的意义上，协程不是并发的，而Goroutine支持并发的。因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。

**线程（Thread）：**  
有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度。

### 知道processor大小是多少吗？

因为会消耗大量的内存 (进程虚拟内存会占用 4GB [32 位操作系统], 而线程也要大约 4MB)。

大量的进程 / 线程出现了新的问题

- 高内存占用
- 调度的高消耗 CPU

### 服务能开多少个m由什么决定

- go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量
- 一个 M 阻塞了，会创建新的 M。

### 开多少个p由什么决定

由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。

### m和p是什么样的关系

M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

### P 和 M 何时会被创建

- P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。

- M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。

## 内存管理

[Golang内存管理](./memory.md)

### 知道golang的内存逃逸吗？什么情况下会发生内存逃逸？

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

能引起变量逃逸到堆上的典型情况：

- 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。- 如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

**案例：**
通过一个例子加深理解，接下来尝试下怎么通过 go build -gcflags=-m 查看逃逸的情况。

```golang

type A struct {
 s string
}

// 这是上面提到的 "在方法内把局部变量指针返回" 的情况
func foo(s string) *A {
 a := new(A)
 a.s = s
 return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
}

func main() {
 a := foo("hello")
 b := a.s + " world"
 c := b + "!"
 fmt.Println(c)
}

PS D:\project\algorithm> go build -gcflags=-m main.go
# command-line-arguments
.\main.go:12:6: can inline foo
.\main.go:19:10: inlining call to foo
.\main.go:22:13: inlining call to fmt.Println
.\main.go:12:10: leaking param: s
.\main.go:13:10: new(A) escapes to heap
.\main.go:19:10: new(A) does not escape
.\main.go:20:11: a.s + " world" does not escape
.\main.go:21:9: b + "!" escapes to heap
.\main.go:22:13: ... argument does not escape
.\main.go:22:13: c escapes to heap
```

- ./main.go:13:10: new(A) escapes to heap 说明 new(A) 逃逸了,符合上述提到的常见情况中的第一种。
- ./main.go:20:11: main a.s + " world" does not escape 说明 b 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。
- ./main.go:21:9: b + "!" escapes to heap 说明 c 变量逃逸，通过fmt.Println(a ...interface{})打印的变量，都会发生逃逸

### GC你了解吗？展开说一下GC的过程

### go内存操作也要处理IO，是如何处理的?

### 项目中如果出现内存泄漏你是怎么排查的？

### 内存申请上有什么区别

## 常用框架

### golang用到哪些框架

### gin框架的路由是怎么处理的？

## 性能

### go性能分析工具

### go的profile工具？

### 用火焰图的优势？

### 火焰图怎么来寻找瓶颈的？

### 说说火焰图？如何分析的？

## channel

### channel和锁对比一下

### channel的应用场景

### channel底层是用什么实现的？

### 向为nil的channel发送数据会怎么样

### 同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题

### go利用channel通信的方式

### channel有缓冲和无缓冲在使用上有什么区别？

### 关闭channel有什么作用？

### go channel实现排序

### go里面channel是什么样的概念

### channel和共享内存有什么优劣势？

### channel的底层有了解过吗

### channel在项目里面是什么作用？

### 有缓冲和无缓冲channel的区别

### channel实现原理

### 被close的channel会有什么问题

### 分布式锁知道哪些？用channel如何实现？

### 集群用channel如何实现分布式锁

## 常见功能

### go实现不重启热部署

### protobuf为什么快

### client如何实现长连接

### 怎么检查go问题

### go怎么实现封装继承多态

### 如何拿到多个goroutine的返回值，如何区别他们

### go里面比较成熟的日志框架了解过没有

### go实现一个并发限制爬虫

### 如何通过goclient写代码获取

### 写个channel相关的题，并发模型，爬虫url，控制并发量

### 参数检查中间件核心功能有哪些？

### 对go的中间件和工作机制有了解吗？

### go使用中遇到的问题

### cgo了解过引入的风险点吗？

### 用go实现一个协程池，大概用什么实现

## go语言如何实现服务不重启热部署

## 你觉得java和golang有什么优势劣势？

## 一个二维数组，行遍历快还是列遍历快，为什么？

1、CPU高速缓存：在计算机系统中，CPU高速缓存是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。  

2、缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。随着数组元素越来越多，按列读取速度也会越来越慢。
