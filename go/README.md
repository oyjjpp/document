# Golang常见问题

## 编译原理

[Golang编译原理](./compile.md)

### go的init函数是什么时候执行的？

### 多个init函数执行顺序能保证吗？

## 数据结构

[Golang数据结构](./struct.md)

### 切片的底层实现说一下？

### Go中对nil的Slice和空的Slice的处理是一致的吗？

nil slice和empty slice是不一致的

### slice，len，cap，共享，扩容

### slice和array区别

### 创建一个数组底层扩容

### 如何把数组转化成一个切片

### 数组和切片的区别

### map和sync.map是有什么区别？看过源码吗，可以介绍一下吗？

### map里面解决hash冲突怎么做的，冲突了元素放在头还是尾

### map取一个key，然后修改这个值，原map数据的值会不会变化

### map如何顺序读取

### struct能不能比较

### go里面interface是什么概念

### go什么场景使用接口

### 函数传递有什么区别

### 相比于javac++interface有什么区别吗？

### make一个slice参数怎么写？

### map会遇到一些并发安全的问题，为什么就并发不安全了？

### 为什么给变量一个基础类型没有并发安全问题？

### 数组和切片的关系和区别

### 结构体传递场景

### string和byte数组有什么区别？

### go结构体和结构体指针的区别

### go深拷贝，什么时候需要深拷贝

### 并发读写map会发生什么？怎么避免?

fatal error: concurrent map read and map write  
会发生并发读写问题

1、在1.9之前可以定义一个结构体加上一把读写锁来解决并发安全问题；
2、1.9之后官方在sync包定义了Map结构体，如果遇到并发问题，可以使用sync.Map解决。  

## 语法基础

## 常用关键字

### defer是啥？怎么用的，底层原理是啥？

### defer用的多吗？有哪些应用

### 异常捕获是如何做的？

### select可以用于什么

### go如何避免panic

### append时的过程

针对切片类型持续进行append可能会导致切片进行扩容

校验是否赋值原有变量

**如果不赋值原有变量:**

1、首先获取当前切片的数组指针、大小、容量  
2、如果追加的元素后，长度大于容量，会触发切片的扩容  
3、最后将追加的元素添加到指定的数组中

**如果赋值原有变量:**  

Go语言编译器已经对这种常见的情况做出了优化  
其他步骤与不赋值原有变量逻辑一致  

**append引发的扩容:**

1、如果期望容量大于当前容量的两倍就会使用期望容量；  
2、如果当前切片的长度小于 1024 就会将容量翻倍；  
3、如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；  

以上仅是针对容量大小的简单计算，还会设计内存对齐

需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能。

## 并发编程

[Golang并发模型](./concurrent.md)

### context

上下文是Go语言中用来设置截止日期、同步信号，传递请求相关值的接口类型；上下文与Goroutine有比较密切的关系；

```golang
type Context interface {
 Deadline() (deadline time.Time, ok bool)
 Done() <-chan struct{}
 Err() error
 Value(key interface{}) interface{}
}
```

主要作用是在多个Goroutine组成的树中同步取消信号以减少对资源的消耗和占用；还有传值的功能，但是这个功能我们还是很少用到。

### go并发机制

### Go语言的互斥锁是怎么实现的？读写锁呢？

### sync pool的实现原理

### go waitgroup的坑

### 读写锁说下

### go的锁是可重入的吗？

### 获取不到锁会一直等待吗？

### 如何实现一个线程安全的map

### 那如何实现一个timeout的锁？

### golang支持哪些并发机制

### go用共享内存的方式实现并发如何保证安全？

### golang wait.group用过吗？

### go里面map是并发安全的吗？不是并发安全该如何使用？

### 怎么理解“不要用共享内存来通信，而是用通信来共享内存”

## 调度器

### Go语言调度器的发展史说一下？

### GMP模型是什么？为什么要有P？

### 主协程如何等其余协程完再操作

### Goroutine是什么？能介绍一下他吗？

### goroutine创建数量有限制吗？

### go协程、线程、进程区别

### 为什么不要频繁创建和停止goroutine

### go里面为什么需要多协程？

### 知道processor大小是多少吗？

### goroutine为什么会存在，为什么不使用线程？

### 服务能开多少个m由什么决定

### 开多少个p由什么决定

### m和p是什么样的关系

### 同时启了一万个g，如何调度的？

### 一个进程能创建多少线程受哪些因素的限制

### goroutine在项目里面主要承担了什么责任

### 用go协程的时候也是要走IO的，go是如何处理的？

### 为什么不要大量使用goroutine

### go里面goroutine创建数量有限制吗？

### 并行goroutine如何实现

## 内存管理

[Golang内存管理](./memory.md)

### 知道golang的内存逃逸吗？什么情况下会发生内存逃逸？

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

能引起变量逃逸到堆上的典型情况：

- 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。- 如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

**案例：**
通过一个例子加深理解，接下来尝试下怎么通过 go build -gcflags=-m 查看逃逸的情况。

```golang

type A struct {
 s string
}

// 这是上面提到的 "在方法内把局部变量指针返回" 的情况
func foo(s string) *A {
 a := new(A)
 a.s = s
 return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
}

func main() {
 a := foo("hello")
 b := a.s + " world"
 c := b + "!"
 fmt.Println(c)
}

PS D:\project\algorithm> go build -gcflags=-m main.go
# command-line-arguments
.\main.go:12:6: can inline foo
.\main.go:19:10: inlining call to foo
.\main.go:22:13: inlining call to fmt.Println
.\main.go:12:10: leaking param: s
.\main.go:13:10: new(A) escapes to heap
.\main.go:19:10: new(A) does not escape
.\main.go:20:11: a.s + " world" does not escape
.\main.go:21:9: b + "!" escapes to heap
.\main.go:22:13: ... argument does not escape
.\main.go:22:13: c escapes to heap
```

- ./main.go:13:10: new(A) escapes to heap 说明 new(A) 逃逸了,符合上述提到的常见情况中的第一种。
- ./main.go:20:11: main a.s + " world" does not escape 说明 b 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。
- ./main.go:21:9: b + "!" escapes to heap 说明 c 变量逃逸，通过fmt.Println(a ...interface{})打印的变量，都会发生逃逸

### GC你了解吗？展开说一下GC的过程

### go内存操作也要处理IO，是如何处理的?

### 项目中如果出现内存泄漏你是怎么排查的？

### 内存申请上有什么区别

## 常用框架

### golang用到哪些框架

### gin框架的路由是怎么处理的？

## 性能

### go性能分析工具

### go的profile工具？

### 用火焰图的优势？

### 火焰图怎么来寻找瓶颈的？

### 说说火焰图？如何分析的？

## channel

### channel和锁对比一下

### channel的应用场景

### channel底层是用什么实现的？

### 向为nil的channel发送数据会怎么样

### 同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题

### go利用channel通信的方式

### channel有缓冲和无缓冲在使用上有什么区别？

### 关闭channel有什么作用？

### go channel实现排序

### go里面channel是什么样的概念

### channel和共享内存有什么优劣势？

### channel的底层有了解过吗

### channel在项目里面是什么作用？

### 有缓冲和无缓冲channel的区别

### channel实现原理

### 被close的channel会有什么问题

### 分布式锁知道哪些？用channel如何实现？

### 集群用channel如何实现分布式锁

## 常见功能

### go实现不重启热部署

### protobuf为什么快

### client如何实现长连接

### 怎么检查go问题

### go怎么实现封装继承多态

### 如何拿到多个goroutine的返回值，如何区别他们

### go里面比较成熟的日志框架了解过没有

### go实现一个并发限制爬虫

### 如何通过goclient写代码获取

### 写个channel相关的题，并发模型，爬虫url，控制并发量

### 参数检查中间件核心功能有哪些？

### 对go的中间件和工作机制有了解吗？

### go使用中遇到的问题

### cgo了解过引入的风险点吗？

### 用go实现一个协程池，大概用什么实现

## go语言如何实现服务不重启热部署

## 你觉得java和golang有什么优势劣势？

## 一个二维数组，行遍历快还是列遍历快，为什么？

1、CPU高速缓存：在计算机系统中，CPU高速缓存是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。  

2、缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。随着数组元素越来越多，按列读取速度也会越来越慢。
