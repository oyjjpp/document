# Golang常见问题

## go的gc原理了解吗？

## go语言的时候垃圾回收，写代码的时候如何减少小对象分配

在 Go 语言中，垃圾回收（Garbage Collection, GC）是自动进行的，由运行时系统（Runtime）管理。运行时系统会定期扫描内存中的对象，并回收不再使用的内存，以避免内存泄漏和use-after-free 错误。因此，在 Go 语言中，程序员无需手动管理内存，可以专注于编写业务逻辑，提高生产力和代码质量。

尽管垃圾回收机制可以自动管理内存，但是过多的小对象分配会导致垃圾回收器频繁地运行，从而导致程序性能下降。因此，在编写代码时，可以采用以下方式来减少小对象分配，以提高程序性能：

1、使用对象池（Object Pool）：在程序初始化阶段创建一定数量的对象，并将它们存储在对象池中，当需要使用对象时，从对象池中获取对象，使用完后将对象返回到对象池中，避免频繁地分配和回收内存。

2、尽量避免使用不必要的结构体（Struct）：结构体通常需要占用一定的内存空间，因此尽量避免在小数据类型中使用结构体。

3、使用值接收器（Value Receiver）：在定义方法时，如果方法只是读取数据而不修改数据，则应该使用值接收器而不是指针接收器。使用指针接收器会导致频繁地分配和回收内存。

4、使用缓冲区（Buffer）：在处理大量小数据时，可以使用缓冲区来避免频繁地分配和回收内存。例如，在处理网络数据时，可以使用 bufio 包提供的缓冲区。

5、手动管理内存：尽管 Go 语言不需要手动管理内存，但是在一些特殊情况下，可以使用内存池等手动管理内存的技术来减少小对象分配，提高程序性能。但是需要注意，手动管理内存会增加代码复杂性和出错的风险，应该谨慎使用。

## gin框架的路由是怎么处理的？

## gmp具体的调度策略

GMP（GNU Multiple Precision Arithmetic Library）是一种高精度计算库，支持多线程和多处理器。在GMP中，调度策略是用来分配线程和任务的方式。GMP中具体的调度策略如下：

1、按需分配：按照任务的优先级和可用的处理器数量，将任务动态地分配给处理器。这种策略适用于任务负载比较均衡的情况。

2、轮询分配：按照一定的顺序将任务分配给处理器。每个处理器依次获取任务并执行，直到完成所有任务。这种策略适用于任务负载不均衡的情况。

3、多队列分配：将任务按照不同的优先级分配到多个任务队列中。不同的队列采用不同的调度策略，例如轮询分配或按需分配。这种策略可以提高任务执行的效率。

4、周期性分配：周期性地将任务分配给处理器。例如，每秒钟将所有任务平均地分配给处理器。这种策略适用于任务负载比较固定的情况。

5、基于负载的分配：根据处理器的负载情况，将任务分配给空闲的处理器。例如，当某个处理器负载过高时，将任务分配给负载比较低的处理器。这种策略可以提高任务执行的效率。

不同的调度策略适用于不同的任务负载和硬件环境。在GMP中，可以根据具体的应用场景选择不同的调度策略，以提高任务执行的效率。

Go语言的运行时系统（runtime）也实现了类似于GMP的调度器，称为M:N调度器（M个goroutine对应N个系统线程）。它采用了以下调度策略：

1、抢占式调度：当一个goroutine发生阻塞、调用了系统函数、或者达到了某个时间片时，调度器会主动中断它的执行，切换到另一个处于就绪状态的goroutine。这种策略可以避免某个goroutine长时间占用CPU资源，提高系统的并发性能。

2、非抢占式调度：当一个goroutine发生阻塞、调用了系统函数、或者主动调用runtime.Gosched()函数时，才会切换到另一个处于就绪状态的goroutine。这种策略可以避免上下文切换的开销，提高系统的性能。

3、work stealing调度：当某个系统线程执行的goroutine数量不足时，会从其他系统线程所属的本地队列中偷取一些goroutine。这种策略可以避免某些系统线程处于空闲状态，提高系统的并发性能。

4、局部队列+全局队列调度：每个系统线程都有一个本地队列，用来存储它需要执行的goroutine。当某个goroutine阻塞、调用了系统函数、或者达到了某个时间片时，会将它放入全局队列。其他系统线程可以从全局队列中获取goroutine执行。这种策略可以提高系统的并发性能。

在Go语言中，调度器的具体实现是由runtime包提供的，可以通过设置环境变量GOMAXPROCS来调整系统线程的数量，从而影响调度器的性能表现。

## go实现不重启热部署

## go性能分析工具

## goroutine创建数量有限制吗？

## go并发机制

## go内存操作也要处理IO，是如何处理的?

## go map并发安全问题，如何解决

## 切片和数组、map、gc、gpm调度模型

## sync pool的实现原理

## map里面解决hash冲突怎么做的，冲突了元素放在头还是尾

## 同一个协程里面，对无缓冲channel同时发送和接收数据有什么问题

## channel和锁对比一下

## channel的应用场景

## slice和array区别

## 向为nil的channel发送数据会怎么样

## map取一个key，然后修改这个值，原map数据的值会不会变化

## Hash实现、冲突解决、应用

## protobuf为什么快

## go waitgroup的坑

## go struct能不能比较

## select可以用于什么

## context包的用途

## client如何实现长连接

## 主协程如何等其余协程完再操作

## slice，len，cap，共享，扩容

## map如何顺序读取
  
## go的垃圾回收机制

## gmp模型

## go的sync.Map了解吗

## channel主要做什么事情

## 怎么检查go问题

## 切片的底层实现

## go和node的差别

## context包内部如何实现的？

## go怎么实现封装继承多态

## 为什么go的变量申请类型是为了什么？

## go slice和map的区别，slice和数组的区别

## go结构体和结构体指针的区别

## go深拷贝，什么时候需要深拷贝

## 如何拿到多个goroutine的返回值，如何区别他们

## go如何避免panic

## go的profile工具？

## go的切片扩容机制

## 用火焰图的优势？

## go里面比较成熟的日志框架了解过没有

## go协程线程进程区别

## 了解的gc算法有哪些？

## go的init函数是什么时候执行的？

## 多个init函数执行顺序能保证吗？

## for range坑输出

## go实现一个并发限制爬虫

## 如何通过goclient写代码获取

## 写个channel相关的题，并发模型，爬虫url，控制并发量

## 参数检查中间件核心功能有哪些？

## 说说火焰图？如何分析的？

## 对go的中间件和工作机制有了解吗？

## go使用中遇到的问题

## cgo了解过引入的风险点吗？

## 为什么不要频繁创建和停止goroutine

## channel底层是用什么实现的？

## go里面为什么需要多协程？

## 知道processor大小是多少吗？

## goroutine为什么会存在，为什么不使用线程？

## string和byte数组有什么区别？

## channel有缓冲和无缓冲在使用上有什么区别？

## 关闭channel有什么作用？

## 用go实现一个协程池，大概用什么实现

## go channel实现排序

## 读过什么go源码没有

## go语言gc了解吗？

## go什么场景使用接口

## 结构体传递场景

## 协程线程区别

## go开发多长时间了？

## 数组和切片的关系和区别

## 内存申请上有什么区别

## 函数传递有什么区别

## 切片底层的架构

## 如何把数组转化成一个切片

## 服务能开多少个m由什么决定

## 开多少个p由什么决定

## m和p是什么样的关系

## 同时启了一万个g，如何调度的？

## go里面channel是什么样的概念

## channel和共享内存有什么优劣势？

## channel的底层有了解过吗

## 数组和切片的区别

## 线程和协程的区别

## 一个进程能创建多少线程受哪些因素的限制

## go里面interface是什么概念

## 相比于javac++interface有什么区别吗？

## goroutine在项目里面主要承担了什么责任

## channel在项目里面是什么作用？

## golang用到哪些框架

## 你觉得java和golang有什么优势劣势？

## golang wait.group用过吗？

## go里面map是并发安全的吗？不是并发安全该如何使用？

## 读写锁说下

## defer用的多吗？有哪些应用

## 异常捕获是如何做的？

## 怎么理解“不要用共享内存来通信，而是用通信来共享内存”

## 用go协程的时候也是要走IO的，go是如何处理的？

## 说下对docker的理解，是解决什么问题的？

## 为什么不要大量使用goroutine

## go里面goroutine创建数量有限制吗？

## 线程和协程有什么区别

## golang支持哪些并发机制

## go利用channel通信的方式

## 有缓冲和无缓冲channel的区别

## channel实现原理

## 被close的channel会有什么问题

## 分布式锁知道哪些？用channel如何实现？


## 并行goroutine如何实现

## go用共享内存的方式实现并发如何保证安全？

## go的锁是可重入的吗？

## 获取不到锁会一直等待吗？

## 那如何实现一个timeout的锁？

## go切片是如何实现的

## go语言如何实现服务不重启热部署

## 如何实现一个线程安全的map

## 创建一个数组底层扩容

## make一个slice参数怎么写？

## 为什么gpm模型会更快？

## 线程协程区别

## 火焰图怎么来寻找瓶颈的？

## map会遇到一些并发安全的问题，为什么就并发不安全了？

## 为什么给变量一个基础类型没有并发安全问题？
