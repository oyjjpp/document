# Mysql常见问题

## 索引

- [深入理解 Mysql 索引底层原理](https://zhuanlan.zhihu.com/p/73204847)
- [纸上得来终觉浅 绝知此事要躬行](https://www.cnblogs.com/MrYuChen-Blog/p/15672292.html)

```mysql
索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。
索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引或优化查询语句。

简单类比一下，数据库如同书籍，索引如同书籍目录，假如我们需要从书籍查找与 xx 相关的内容，我们可以直接从目录中查找，
定位到 xx 内容所在页面，如果目录中没有 xx 相关字符或者没有设置目录（索引），那只能逐字逐页阅读文本查找，效率可想而知。
```

### 为什么使用索引

最主要的原因是使用提高效率:

- 快速查找匹配where子句中的行
- 如果可以在多个索引中选择，mysql通常会使用找到最少行的索引
- 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
- 当有表连接的时候，从其他表检索行数据
- 查找特定索引列的min和max的值
- 如果排序或者分组时可用索引的最左前缀完成的，则对表进行排序和分组
- 在某些情况下，可以优化查询以检索数据值而无需查找数据行

### 索引的优缺点

优点：

- 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 索引可以帮助服务器避免排序和创建临时表【B+树已经排序过的】
- 索引可以将随机IO变成顺序IO，减少IO次数
- 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性
- 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
- 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要- 建立聚簇索引，那么需要占用的空间会更大
- 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
- 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
- 对于非常小的表，大部分情况下简单的全表扫描更高效；

### 创建索引准则

应该创建索引的列：

```mysql
1、在经常需要搜索的列上，可以加快搜索的速度；
2、在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
3、在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度[少用]；
4、在经常需要根据范围（<，<=，=，>，>=，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
5、在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
6、在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
```

不该创建索引的列：

```mysql
1、对于那些在查询中很少使用或者参考的列不应该创建索引。若列很少使用到，因此有索引或者无索引，并不能提高查询速度。
相反由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

2、对于那些只有很少数据值或者重复值多的列也不应该增加索引。【数据去重后的数据比趋于1,则索引效果越好】
这些列的取值很少，例如用户信息表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，
即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

3、对于那些定义为text, image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。

4、当该列修改性能要求远远高于检索性能时，不应该创建索引。（修改性能和检索性能是互相矛盾的）
```

### 索引的分类

```mysql
主键索引(唯一且非空)【数据库默认建立的索引是给唯一键建立的】
唯一索引(唯一可为空)
普通索引(普通字段的索引)
全文索引(一般是varchar,char,text类型建立的，但很少用)
组合索引(多个字的建立的索引)
```

### mysql索引结构？

```mysql
MySQL中常用的索引结构（索引底层的数据结构）有：B-TREE ，B+TREE ，HASH 等。
```

### 索引结构——二叉树

特性：  

- 所有非叶子结点至多拥有两个子节点（Left和Right）；
- 所有结点存储一个关键字；
- 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

```mysql

二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点关键字相等，则该结点为查询的结点，如果查询关键字比结点关键字小，则进入左子树，反之则进入右子树；如果左子树为空或者右子树为空，则返回查找不到响应的关键字；
如果二叉搜索树的所有叶子结点的左右子树的树木保持一个平衡即左右子树个数大致相等的话，其搜索则更接近与二分查找；但是它相比连续内存空的二分查找的优点是：改变二叉搜索树的结构（添加或者删除）不需要大段的移动数据，甚至通常都是常数开销；
```

![image](./image/20211208161626836.png)

```mysql
当一个二叉树经历多次删除操作后，就会出现树不平衡的状态，如上图所示。

右边也是一个搜索二叉树，只不过不在平衡了，他的搜索功能也变成了线性的，同样的关键字可能导致不同的树结构索引，所以，在使用搜索二叉树时，还要考虑尽可能让B树保持左图的结构，避免和右图类似，这也有事所谓的平衡问题了；

实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即平衡二叉树；如何保持B树节点分布均匀的平衡算法就是平衡二叉树的关键所在，平衡算法是一种在二叉搜索树的插入和删除结点时的一种策略。即：在插入或删除的同时保持二叉搜索树的平衡。
```

### 索引结构——B Tree

```mysql
B-树,这里的B表示balance(平衡的意思),B-树是一种多路自平衡的搜索树（B树是一颗多路平衡查找树）它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点；
```

B树是一种多路搜索树，一棵m阶的B树满足下列条件：

- 树中每个结点至少有M个孩子
- 根结点的子节点数为[2,M）
- 除根结点以外的非叶子结点的儿子数为[M/2, M]；
- 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
- 非叶子结点的关键字个数 = 指向子节点的指针个数-1；
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子结点位于同一层；

B树的特征:

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制；
- B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的子结点；重复，直到所对应的子指针为空，或已经是叶子结点；

### 索引结构——B+Tree

```mysql
B+树是B-树的变体，也是一种多路搜索树，特性和B-类似，不同在于：

1、所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)
2、为所有叶子结点增加了一个链指针
```

```mysql
B+ 树的磁盘读写代价更低：B+ 树的数据都集中在叶子节点，分支节点 只负责指针（索引）；B 树的分支节点既有指针也有数据 。这将导致B+ 树的层高会小于B 树的层高，也就是说B+ 树平均的Io次数会小于B 树。

B+ 树的查询效率更加稳定：B+ 树的数据都存放在叶子节点，故任何关键字的查找必须走一条从根节点到叶子节点的路径。所有关键字的查询路径相同，每个数据查询效率相当。

B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，遍历只需要扫描一遍叶子节点即可；B树因为其分支结点同样存储着数据，要找到具体的数据，需要进行一次中序遍历按序来搜索。

B+树更擅长范围查询：B+树叶子节点存放数据，数据是按顺序放置的双向链表。B树范围查询只能中序遍历。

B+ 树占用内存空间小：B+ 树索引节点没有数据，比较小。在内存有限的情况下，相比于B树索引可以加载更多B+ 树索引。
```

### 覆盖查询和回表查询

```mysql
在非主键索引上可以查询到所需要的字段，不需要回表再次查询就叫覆盖索引。

name字段是普通索引，从name列的B+树找到主键，再从主键的B+树找到最终的数据，这就是回表。(主键索引的叶子节点保存的是列的所有数据，但是普通所有的叶子结点保存的是对应的主键ID）

总结：通过普通索引B+树确定主键值，再到主键索引树，查找到具体数据，即为回表
```

### 聚簇索引和非聚簇索引

```mysql
InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。
```

### mysql主键索引和非主键索引在搜索和检索过程中有什么区别吗？

```mysql
聚簇索引（clustered index）不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。

非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。
```

聚簇索引优点：

- 聚簇索引对于主键的排序查找和范围查找速度非常快
- 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快

聚簇索引缺点：

- 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）

- 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。

- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

### 哪些键可以设置唯一索引

```mysql
数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
```

### 什么场景下联合索引会失效？

- 索引列上出现类型转换
- 存储引擎不能使用索引范围条件右边的列
- mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描
- is null,is not null也无法使用索引
- like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。

### 最左匹配原则？问为什么有这个东西？

```mysql
组合索引中 先匹配左边，再继续向后匹配；比如user表中有name+age组成的联合索引，select * from user where name="纪先生" and age = 18 就符合最左匹配，可以用的索引。而select * from user where age = 18就不符合，用不到这个索引。

总结：组合索引顾头不顾未，想要使用索引，必须从组合索引的第一个字段开始。
```

### 数据库如何建索引

```mysql
主键索引
ALTER TABLE TableName ADD PRIMARY KEY(column_list); 

唯一索引
CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));
# 或者
ALTER TABLE TableName ADD UNIQUE (column_list); 

普通索引
CREATE INDEX IndexName ON `TableName`(`字段名`(length));
# 或者
ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length));
```

### sql索引优化问题

### MySQL优化（索引、分表分库）

### mysql索引，mongodb和mysql索引的区别，给了条sql语句问索引怎么构建

## 性能

### explain字段含义

### sql查询性能瓶颈处理方式

### 一条update语录执行流程

### 一条sql的查询过程

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1a573fad98d453ba60f9babdade0b8d~tplv-k3u1fbpfcp-watermark.image)

### 什么操作会影响联表查询效率

### 分析sql性能好坏如何分析？

### 一条sql语句比较慢用什么方式去优化？

### sql慢查询

### mysql索引慢分析：线上开启slowlog，提取慢查询，然后仔细分析explain中tye字段以及extra字段，发生的具体场景及mysql是怎么做的

## 事务

### 事物四个特性？四种隔离级别？分别解决了什么问题？

ACID(原子性、一致性、隔离性、持久性)

### innoDB支持事务，他为什么支持事务？MYSQL是如何保证的？

### MVCC原理

### 默认的事务隔离级别是什么？

### 这个隔离级别是如何实现的？

### mysql如何实现事务的？

### 如果实现分布式事务？

## 分库分表

### 分库分表查询方式，数据库分库分表，什么时候分库什么时候分表

### mysql分库分表平滑扩容方案

### 最终一致性

### mysql分布式id

### 分库之后唯一性如何保证

### 分库分表分区有哪些差别？

### 分表遇到联表查询怎么分页？

### 分库分表常用模式

### 一开始一个项目数据比较多，后来需要分库分表，有什么思路在不停服务的情况下做到平滑切换？

## 设计

### 设计用户详情的表，如何生成主键

### 对mysql的设计掌握如何？

### 数据库用过哪些？

## 存储引擎

### mysql默认的存储引擎

### mysql的存储引擎了解哪些？区别是啥？

```mysql
InnoDB、MyISAM、memory、archive
mysql存储引擎是可插拔的，核心基础代码是与存储引擎分离的

1、InnoDB  
优点  
a、灾难恢复性好  
b、支持全部4种级别的事务  
c、使用行级锁  
d、对于innodb引擎中的表，数据的物理组织形式是簇表（数据按主键来组织，主键索引和数据是在一起的） 
e、实现了缓存管理  

2、MyISAM  
特点  
a、可以配合锁，实现操作系统下的复制备份，迁移  
b、使用表级锁，并发性能差  
c、支持全文检索  
d、灾难恢复性不佳  
e、不支持事务  
f、仅缓存索引  

3、memory  
提供内存表，也不支持事务，外键；使用内存表可以显著提供访问数据的速度，可以应用于频繁访问的  

4、archive  
被设计用来存储企业中的大量流水数据的存储引擎，使用zlib无损数据压缩，适合做日志记录，用户行为分析


```

## Mysql相关锁

### 锁的类型用过哪些

### 什么叫悲观锁？什么叫乐观锁？

### 乐观锁如何保证最终一致性？

### 脏读幻读说一下？

## 主从

### mysql主从同步过程了解吗？

### 复制原理及流程

## 缓存

### 缓存和数据库一致性的问题

[如何保持mysql和redis中数据的一致性？](https://www.zhihu.com/question/319817091/answer/2176813916)

## 知道mysqlinnodb是什么数据结构吗？

## 数据库加密算法是怎么设计的？设计这种东西通用规范是怎么设计的？
